클래스 배열
	객체를 여러개 선언해야 하는 경우 배열 타입으로 한번에 선언 후 사용
	각 객체는 규칙성이 없기 때문에 규칙성을 부여하기 위해서 사용
	배열의 한칸 한칸이 하나의 객체

클래스 배열 선언
	클래스명[] 배열명 = {
		new 생성자(),
		new 생성자(),
		...
	};		
	
	클래스명[] 배열명 = new 클래스명[칸수]

클래스 배열 사용
	각 칸이 객체이기 때문에 각 방으로 접근 후 . 을 찍고 필드로 접근한다.

	배열명[idx].변수
	배열명[idx].메소드()

static(정적)
	전역변수 : 각 객체의 필드에 생성되는 변수들

	static이 붙은 변수, 메소드, 구역 등은 프로그램 실행시 가장 먼저
	메모리에 올라간다. static이 붙은 메소드 내부에서는 객체의 필드에
	올라오는(생성되는) 일반 전역변수나 일반 메소드는 사용할 수 없다.
	(아직 메모리에 생성되지 않았기 때문에)
	따라서 static이 붙은 전역변수, static이 붙은 메소드, 자기자신 안에 선언된
	지역변수만 사용할 수 있다.

	static이 붙은 전역변수, 메소드는 모든 객체가 공유된다.
	따라서 static 필드는 클래스 이름으로 직접 접근이 가능하다.
	각 객체가 실제로 공유해야 하는 값이나 메소드, 또는 필드가 필요없는 메소드
	같은 경우에는 static을 붙여서 선언하여 관리한다.
	(공유하지 않아야하는 값들에는 무조건 static을 붙이면 안된다)	

클래스 사용방법
	1. 데이터 포장
	2. 기능 관리

	* 기획
	// CRUD(Create, Read, Update, Delete)
	1. 성적 등록
		이름 :
		반 :
		번호 :

		국어점수 :
		수학점수 :
		영어점수 :

		~~~의 점수 등록이 완료되었습니다.
	2. 성적 수정	
		반 :
		번호 :
		수정할 과목 :
		새로운 점수 :
		
		~~~ 점수 수정이 완료되었습니다.
	3. 학생 자퇴
		반 :
		번호 :
		
		진심 ? :
		~~~ 안녕 ~~
	4. 점수 조회
		반 :
		번호 :

		국어점수 : ~~~
		총점 : 100점 / 평균 : 33.3333점
	5. 나가기

상속(inheritance)
	1. 기존에 선언된 클래스의 필드를 다른 클래스에서도 사용하고자 할 때 

상속 방법
	class A {
		A의 필드
	}

	class B extends A {
		B의 필드
	}

	B obj = new B( );
	obj 객체는 실제로 A의 필드와 B의 필드를 둘 다 가지고 있다.

	A : 부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스
	B : 자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스

자식 클래스의 생성자 호출 시 일어나는 일
	자식 클래스의 객체는 자식 생성자를 호출하여 객체화를 진행한다.
	자식 생성자를 호출했으므로 자식 클래스 내의 필드들이 똑같이
	복사되어 하나 생성된다. 만약 자식 클래스의 필드만 메모리에 올라갔다면
	자식 객체로 절대 부모 클래스의 내부에 있는 필드는 사용할 수 없다.
	따라서 자식 생성자를 호출하게 되면 상속 받기로 한 부모 필드가 먼저
	메모리에 할당되고 그 이후에 자식 필드도 따라 붙는다. 결과적으로
	자식 객체는 부모 필드가 메모리에 같이 올라와 있기 때문에
	부모 클래스의 필드에도 접근할 수 있게된다.
	>> 자식 생성자의 첫 줄에는 항상 super 클래스의 생성자가 호출된다.
	명시적으로 부모 생성자를 호출하지 않는다면 super() 호출

다형성 (Polymorphism)
	1. Overloading
	
	2. Overriding(오버라이딩) : 재정의
	부모 필드에 a() 라는 메소드가 존재한다면 자식 객체 생성시
	부모 필드가 먼저 메모리에 올라가게 되므로 부모의 a()가
	메모리에 먼저 존재한다. 그 다음 자식 필드를 완성시킬 때
	똑같은 이름의 a() 라는 메소드가 존재한다면 같은 이름과
	같은 매개변수를 가진 2개의 메소드가 만들어지는 것이 아니라
	기존에 만들어진 부모 필드의 a() 메소드 대신에 자식에서 작성한
	내용이 덮어 씌워지게 된다. 그러므로 자식 객체로 a() 메소드를
	사용하게 되면 재정의된 기능으로 작동하게 되며 이것을
	오버라이딩 이라고 한다.